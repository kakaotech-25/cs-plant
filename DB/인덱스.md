인덱스(Index)는 데이터베이스에서 원하는 데이터를 빠르게 검색하고 접근하기 위해 사용되는 자료구조이다. 구체적으로는, 이 자료구조 내에서 각 단위를 인덱스라고 지칭하며, 여러 종류의 인덱스 중에서 노드(node)가 데이터 레코드(실제 데이터)를 포인터로 가리키는 형태이다. 대부분의 DBMS는 인덱스의 저장 방식으로 B-Tree, B+Tree, 그리고 Hash 자료구조를 채택하고 있다.

각 인덱스는 데이터 레코드의 특정 컬럼을 대상으로 하여, 컬럼의 값과 해당 레코드가 저장된 주소(포인터)를 key-value 쌍으로 저장한다.

정확히는, 이 자료구조 내에서 각 단위를 인덱스라고 지칭하며, 여러 종류의 인덱스 중에서 노드(node)가 데이터 레코드(실제 데이터)를 포인터로 가리키는 형태이다. 대부분의 DBMS는 인덱스의 저장 방식으로 B-Tree, B+Tree, 그리고 Hash 자료구조를 채택하고 있다.

조회(select)을 위한 최적화된 구조 인덱스는 B+ Tree와 같은 저장 방식을 취함으로써 항상 정렬된 상태를 유지한다. 반면, 인덱스들이 가리키는 데이터 파일의 레코드들은 별도의 순서 정렬 없이 데이터가 유입되는 대로 저장된다. 따라서 DBMS 상에서 인덱스는 데이터의 저장(insert, delete, update) 성능을 희생한 대신, 조회(select)의 성능을 최적화한 구조이다.

B-Tree 인덱스
B-Tree는 이진트리와 달리 자식 노드를 여러 개 가질 수 있는 균형 잡힌(Balanced) 트리 구조이다. 최상위에는 루트 노드(root node)가 존재하고, 맨 하위 계층에는 리프 노드(leaf node)가 존재하며, 이들 사이에 중간 노드로 브랜치 노드(branch node)가 존재한다. 여기서 key 값이란, 실제 데이터 레코드의 key 값을 의미하며, 각 레코드를 식별할 수 있는 (중복되지 않는) 값을 지닌 컬럼의 값을 의미한다. 대표적으로 프라이머리 키(primary key)가 이에 해당한다.

B+ Tree와 다른 점은 리프 노드에서 가장 두드러진다. B+ Tree의 리프 노드는 서로 링크드 리스트로 연결된 형태이지만, B-Tree는 그렇지 않다.

B+ Tree 인덱스
B-Tree와의 차이점: 리프 노드
B+ Tree는 B-Tree에서 응용된 구조로, 몇 가지 차이점을 가진다. 우선, B-Tree는 모든 노드에서 레코드의 primary key 값을 저장하지만, B+ Tree는 오직 리프 노드에서만 실제 레코드의 primary key 값을 저장한다.

리프 노드는 실제 레코드를 가리키기 위한 포인터를 저장하며, 이는 비클러스터링 인덱스(Non-Clustering Index)에 해당한다.

더블리 링크드 리스트
같은 깊이에 있는 리프 노드들은 서로 링크드 리스트 구조로 연결된다. 이에 따라, 리프 노드들은 더블리 링크드 리스트로 연결된 구조를 가진다.
이로 인해 B+ Tree는 레인지 스캔(Range Scan)이나 풀 스캔(Full Scan)을 수행할 때 B-Tree보다 훨씬 유리하다. 특정 리프 노드에서 시작해 링크드 리스트를 따라 순차적으로 선형 탐색을 하면 되기 때문이다.

반면, B-Tree는 링크드 리스트로 연결되지 않았기 때문에, 모든 노드를 일일이 스캔해야 한다는 번거로움이 있다.

더 많은 인덱스를 담을 수 있는 구조
리프 노드를 제외한 노드들은 데이터를 담지 않기 때문에, 더 많은 key를 수용할 수 있으며, 트리의 높이를 낮출 수 있다. 이는 캐시 히트(cache hit)율을 높이는 데 도움이 된다.
B+ Tree 레코드 테이블
인덱스는 테이블의 key 컬럼만 저장하므로, 레코드의 나머지 컬럼(Secondary Index)을 조회하려면 데이터 파일에서 해당 레코드를 찾아야 한다.

InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때, 데이터 파일은 즉시 조회되지 않는다. 데이터 파일도 B+ Tree 구조로 구현되어 있기 때문이다. 따라서 인덱스에서 찾은 key 값과 일치하는 레코드를 데이터 파일의 B+ Tree 구조에서 다시 조회해야 한다.

결론적으로 InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스를 검색해 데이터 레코드를 조회할 때, 반드시 key 값을 저장한 B+ Tree를 다시 탐색해야 한다.

B+ Tree의 인덱스 key 연산
테이블의 레코드를 저장하거나 변경할 때는 인덱스의 key 값이 추가, 변경, 삭제되는 연산이 발생한다. 이 과정을 이해하면 쿼리 성능을 예측하기 쉬워진다.

인덱스 key 값 추가
새로운 key 값을 저장할 때는 루트에서 시작해 범위 값을 비교하며 삽입될 리프 노드를 찾아가서 삽입한다. 만약 리프 노드가 꽉 찼다면, 리프 노드는 split된다.

split된 후 새로운 오른쪽 노드의 첫 번째 원소는 부모 노드에 삽입되며, 부모 노드에서도 split이 발생할 수 있다. 이 과정이 루트 노드까지 전파될 수 있기 때문에, B+ Tree의 key 값 추가는 비용이 많이 든다.

이런 단점 때문에 InnoDB 엔진에서는 INSERT문이 실행되면 인덱스의 key 추가 작업을 지연시켜 나중에 한 번에 처리한다. 하지만 primary key나 unique key 인덱스의 경우 중복 체크가 필요해 즉시 B+ Tree에 추가하거나 삭제한다.

인덱스 key 값 삭제
삭제는 간단하다. 리프 노드에서 해당 key 값을 찾아 삭제하면 된다. 삭제된 공간은 나중에 재활용될 수 있다.

삭제된 key 값이 가리키는 실제 레코드는 데이터 파일에서 삭제되지 않고, 그저 인덱스를 잃은 상태가 된다.

인덱스 key 값 변경
인덱스의 key 값은 리프 노드의 위치를 결정하므로, 단순한 변경은 불가능하다. 먼저 기존 key 값을 삭제한 후, 새로운 key 값을 추가하는 방식으로 처리된다. InnoDB 엔진에서는 이 작업이 체인지 버퍼(Change Buffer)를 통해 지연 처리될 수 있다.

인덱스 key 값 조회
특정 key 값을 조회하는 경우, 루트에서 시작해 리프 노드까지 내려가 key 값을 조회하면 된다. 이 연산은 O(logbN) 시간에 수행된다.

다만, key 값이 변형된 경우 B+ Tree의 장점을 누릴 수 없다. 변형된 key 값은 B+ Tree 인덱스에 존재하지 않기 때문에, 함수를 사용한 정렬이나 검색은 주의해야 한다.
