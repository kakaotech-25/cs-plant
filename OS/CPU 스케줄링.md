# CPU 스케줄링
- CPU스케줄링은 운영체제에서 CPU 자원을 효율적으로 관리하기 위해 사용된다. 운영체제는 동시에 여러 프로세스가 실행될 때, 각 프로세스가 얼마나, 언제 사용할지 결정해야 하는데 이때 어떤 프로세스를 다음에 처리할지 선택하는 알고리즘을 CPU 스케줄링이라고 한다.
- CPU 사용의 최적화를 통해 시스템 성능을 향상시키고, 처리량, 응답 시간을 개선하며 프로세스 간의 공정성을 보장하는 것을 목표로 하고 있다.
- 적절한 스케줄링을 통해 시스템의 전반적인 성능과 사용자 경험에 직접적인 영향을 끼치기에 CPU를 효율적으로 사용하도록하여 시스템 성능을 극대화하고 사용자에게 빠른 응답을 제공할 수 있다.

# 선점 스케줄링 VS 비선점 스케줄링
- CPU 자원을 프로세스에 할당하는 방법에 따라 크게 선점 스케줄링과 비선점 스케줄링으로 나눌 수 있다.

## 선점 스케줄링
- 프로세스가 CPU를 사용하고 있는 도중에도, 더 중요한 작업이 발생하거나, 우선순위가 높은 프로세스가 등장하면 현재 프로세스에서 CPU를 강제로 빼앗아 다른 프로세스에게 할당하는 방식
- 장점 : 중요한 작업을 빠르게 처리하거나 다수의 작업을 효율적으로 관리하는 데 유리함
- 단점 : Context Switching이 자주 발생하면 시스템에 오버헤드가 발생할 수 있음

### [대표적인 선점 스케줄링 알고리즘]
##### **1. SRT 스케줄링** (Shortest Remaining Time)
- 비선점 스케줄링 알고리즘인 SJF의 선점형 버전
- 현재 실행중인 프로세스와 새롭게 도착한 프로세스의 남은 CPU 버스트 시간을 비교하여, 남은 시간이 더 짧은 프로세스에 CPU를 할당함
- 동작과정 : 새로운 프로세스가 도착하면 현재 CPU를 사용중인 프로세스의 남은 실행 시간과 비교한다. 새로 도착한 프로세스의 남은 실행 시간이 더 짧다면 현재 프로세스는 CPU를 선점당하고, 새 프로세스가 CPU를 할당받는다.
- 장점 : 평균 대기 시간을 최소화할 수 있고 짧은 작업이 우선 처리되어 전체 시스템의 응답 시간을 줄일 수 있음
- 단점 : 짧은 프로세스가 계속해서 새로 도착하면 긴 프로세스가 영원히 CPU를 할당받지 못하는 기아현상이 발생할 수 있음, 또한 전환이 빈번하게 발생하여 오버헤드가 증가할 수 있음

##### **2. RR 스케줄링** (Round Robin)
- 시분할 시스템에서 주로 사용되는 선점형 스케줄링 알고리즘
- 모든 프로세스가 동일한 시간동안 CPU를 사용할 수 있도록 보장함
- 동작과정 : 준비큐에 있는 프로세스들에게 순차적으로 일정한 시간동안 CPU를 할당한다. 프로세스가 주어진 시간 내에 완료되지 않으면 CPU를 반납하고 준비큐의 마지막으로 들어가서 다시 대기한다. 다음 프로세스가 같은 방식으로 CPU를 할당받아 작업을 수행한다.
- 장점 : 공정성이 좋고, 모든 프로세스가 주기적으로 CPU를 사용할 수 있음, 대기 시간이 짧아져 시스템 응답성이 개선됨
- 단점 : Time Quantum의 크기가 너무 크면 FCFS와 비슷해져서 공정성의 이점이 사라지며, 너무 작으면 전환이 자주 발생하여 오버헤드가 증가함

##### **3. 선점형 Priority 스케줄링**
- 각 프로세스에 우선순위를 부여하고 우선순위가 높은 프로세스에 CPU를 먼저 할당하는 방식
- 동작과정 : 각 프로세스에 우선순위를 부여한다. 도착한 새로운 프로세스의 우선순위가 현재 실행 중인 프로세스보다 우선순위가 높다면 현재 프로세스는 선점당하고, 새로운 프로세스가 CPU를 사용하게 된다.
- 장점 : 중요한 작업을 빠르게 처리할 수 있음 시스템이 중요한 프로세스에 더 많은 자원을 할당하도록 함
- 단점 : 우선순위가 낮은 프로세스는 CPU를 할당받지 못해 오랫동안 대기하는 기아현상이 발생할 수 있음 이를 해결하기 위해서는 대기시간만큼 프로세스의 우선순위를 높여주는 방식을 사용할 수 있음


## 비선점 스케줄링
- 한번 CPU를 할당받은 프로세스가 I/O 작업을 요청하거나, 작업이 끝날때까지 CPU를 계속해서 점유하는 방식으로 중간에 다른 프로세스가 CPU를 빼앗을 수 없음
- 장점 : 오버헤드가 적고, 작업이 안정적으로 완료될 수 있음
- 단점 : 긴 작업이 먼저 CPU를 점유하면 중요한 작업이 뒤로 밀려서 대기 시간이 길어질 수 있음

### [대표적인 비선점 스케줄링 알고리즘]
##### **1. FCFS 스케줄링** (First-Come, First-Served)
- 먼저 도착한 프로세스에게 CPU를 할당하는 가장 간단한 알고리즘
- 동작과정 : 준비큐에 도착한 순서대로 프로세스가 CPU를 할당받는다. 작업이 완료될 때 까지 해당 프로세스는 CPU를 점유한다. 이 과정에서 I/O 작업이나 종료 작업이 발생하지 않으면 다른 프로세스는 CPU를 사용할 수 없다.
- 장점 : 구현이 매우 간단하고 공정하게 처리됨
- 단점 : *Convoy Effect가 발생할 수 있음 실행시간이 긴 프로세스가 먼저 도착하면 뒤에 도착한 짦은 작업들이 오랫동안 대기해야 하는 문제가 발생할 수 있음 이로인해 전체 시스템의 응답 시간이 길어질 수 있음
- *convoy Effect : 실행시간이 긴 프로세스가 준비큐에 먼저 도착하여 CPU를 점유하게 되면 그 뒤에 도착한 짧은 작업들이 오랫동안 대기하게 되는 현상

##### **1. SJF 스케줄링** (Shortest Job First)
- CPU 버스트 시간이 가장 짧은 프로세스를 먼저 실행하는 방식
- 동작과정 : 준비큐에 있는 프로세스 중 CPU 버스트 시간이 가장 짧은 프로세스에 CPU를 할당한다. 이 때 CPU를 할당받은 프로세스는 작업이 완료될 때까지 CPU를 점유한다.
- 장점 : 평균 대기 시간을 최소화할 수 있어 시스템의 처리 효율을 높임
- 단점 : 기아현상이 발생할 수 있음. 긴 작업이 대기 중일 때 짧은 작업이 계속해서 새로 도착하면 계속 대기 상태로 머무르게 되는 경우가 생길 수 있음

##### **3. 비선점형 Priority 스케줄링**
- 각 프로세스에 우선순위를 부여하고 우선순위가 높은 프로세스에 CPU를 먼저 할당하는 방식
- 선점형 Priority 스케줄링과는 달리 CPU를 할당받은 프로세스는 작업이 끝날 때까지 CPU를 점유함
- 동작과정 : 모든 프로세스에 우선순위가 부여되고, 준비큐에 있는 프로세스 중 우선순위가 가장 높은 프로세스가 CPU를 할당 받는다. 선점형과 달리 한번 CPU를 할당받은 프로세스는 작업이 끝날 때까지 CPU를 점유한다.
- 장점 : 중요한 작업을 빠르게 처리할 수 있음
- 단점 : 우선순위가 낮은 프로세스는 CPU를 할당받지 못해 오랫동안 대기하는 기아현상이 발생할 수 있음 이를 해결하기 위해서는 대기시간만큼 프로세스의 우선순위를 높여주는 방식을 사용할 수 있음

